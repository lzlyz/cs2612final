# 函数指针与多态函数 小组

### 题目:

【前端实现】带函数指针与类型多态的程序语言的词法分析、语法分析与类型多态展开

这个任务中，你需要在 `WhileF` 语言中加入函数指针、基本类型系统与类型多态。该语言的类型包括整数类型、某类型的指针类型与基于特定参数与返回值类型的函数指针类型，声明变量时需要使用 `var` 关键字 + 类型 + 变量名，类型多态使用类似 `C++` 语言中 `template` 的语法表示。

要求 1：在 `WhileF` 语言中加入函数指针与基本类型系统，并完成词法分析、语法分析与语法树输出。

要求 2：进一步加入类型多态，并完成词法分析、语法分析与语法树输出。

要求 3：实现类型检查，根据 `main` 函数的需要，将类型多态展开，不能展开成为有穷多个副本的，产生报错信息。

### 完成情况:

要求1： 完成

要求2： 完成

要求3： 完成

### 调用:

我们调用了一个由N. Devillard制作的dictionary的实现，该dictionary利用字符串作为key，找到一个相应的指针。

该dictionary实现其实非常简单，它的本质只是一个结构体数组，并没有用到字典树，红黑树等查询复杂度为O(logN)的数据结构，具体只使用了哈希函数来辅助字符串比对。

为了方便我们依然使用了这个实现，具体文件为ours文件夹下的dictionary.h和dictionary.c。

### 约定:

1. 由于没有数组，我们禁止了函数指针进行二元运算。由于多态函数可以传入指针作为类型，对于多态类型，我们也禁止了其进行二元运算。
2. 不考虑函数重载。具体实现中，禁止了函数重载。
3. 声明方式：
```
函数指针、指针、变量：
var TYPENAME RIGHT_TYPE_EXPR;
函数:
func TYPENAME RIGHT_TYPE_EXPR;
过程:
func void RIGHT_TYPE_EXPR;
多态函数:
template <typename NEW_TYPENAME> TYPENAME RIGHT_TYPE_EXPR
 
其中：
TYPENAME->NEW_TYPENAME, TYPENAME->INT
``` 
考虑到多态过程没有什么意义，

4. 函数原型仅能声明一次。
5. 多态函数实例化必须使用`POLYMORPHIC_FUNCTION< TYPENAME ANNON_TYPE_EXPR >`，这个会被看作一个实例化后的普通函数，在这个函数上再进行函数调用`(ARGUMENTS)`。有且仅有一个模板类型名(`template typename`)。
6. 我们约定函数调用会被看作为一个`expr`，过程调用会被看作为一个`cmd`。
7. 我们修改了一点点原有的`WhileF`语法。原有的WhileF语法要求`cmd`之间用分号`;`进行分开，但是这个在实际写代码的时候有些反直觉，所以在我们的实现中，用分号`;`表示cmd的结尾，包括函数声明。
8. 使用函数指针对应的函数前必须解引用(即`&`, derefrence)。
9. 考虑到多态过程本身的意义并不大，我们没有加入多态过程，但是我们设计的类型多态展开的算法是可以完成多态过程的展开的任务的。
10. 不存在多态函数的指针。(否则应当无法完成类型多态展开)

### 关键实现方式:

要求 1：不难，理解flex和bison后，按照要求加入对应语法即可。

要求 2：我们利用`var_type`(见lang.h)来储存一个变量及其数据类型、或是一种数据类型。由于原来作业(struct&union&enumration)中，对于以函数的指针作为返回值的函数的指针的语法树输出不正确，我们重写了`RIGHT_TYPE_EXPR`(在代码中是`var_decl_expr`，见lang.h)的相关代码，让函数指针的定义符合要求。然后，我们加入了按照语法加入了类型多态。

要求 3：要求3相比要求1、2难度大很多，主要分为两点:

要求 3.1: 类型检查。类型检查主要包含：`expr`参与的各种运算和赋值语句是否符合类型要求、定义语句是否符合要求、函数过程调用是否符合要求、变量是否存在、等等。我们为`expr`加入了一个`var_type`指针表示其类型来进行实行类型检查。对于不符合类型要求的语句，我们产生报错信息，并且退出。

要求 3.2: 类型多态展开。我们先介绍我们的类型多态展开的想法。如果一个多态函数在`main`函数的要求下会产生无穷个副本有如下几点步骤(在下面的描述中，我们使用`T`来代表多态函数的模板类型名，即template typename)：
1. 多态函数会展开成无穷个副本，与`main`函数实例化多态函数时提供的实例化类型无关。这是十分显然的。
2. 多态函数会展开成无穷个副本，一定从这个多态函数出发，直接或间接调用到了自己，且实例化的类型与最开始不同。结合上面的`步骤1`，我们可以知道，一个多态函数会展开成无穷个副本，`当且仅当`，它在`main`函数的要求下被实例化，且它在能够从类型`T`出发，直接或简介调用到类型为包含`T`，但是不是原本的`T`的自己。
3. 判断直接调用非常简单。判断间接调用的情况，我们可以用DFS，从一个多态函数出发，访问二元组(多态函数，类型)，其中类型分为两种，一个是"原本的`T`"，另一个是"含`T`但不是原本的`T`"，每个二元组只访问一次，访问之后就打上`visited`，如果从(原函数,"原本的`T`")出发达到了(原函数,"含`T`但不是原本的`T`")，则这个函数会展开成无穷多个副本，报错。具体代码详见lang.c中有关 PT (polymorphic test)的部分。
4. 剩下的就是展开所有的多态函数的实例化。这部分详见lang.c中有关 FT(function traversing), PFE(polymorphic function expasion)的部分。简单来说，遍历每一个函数，然后将(多态函数，展开类型)对应到一个展开后的函数。

### 怎么使用:

1. 在./ours下 make。我们提交的代码已经提前在Windows上提前make好了，在windows上应该能直接测试，如果要使用Linux，建议重新make一下。
2. 运行编译得到的 main(on Linux) 或 main.exe (on Windows)。需要参数，参数为同文件夹下的文件名。如
```shell
main normal/test1.jtl
```
```powershell
.\main.exe .\normal\test1.jtl
```
3. 我们提供了大量的测试样例来检测我们的工作成果，详见./ours/error，该文件夹下的样例均为报错的样例。详见./ours/normal，该文件夹下的样例均为正常输出的样例。

